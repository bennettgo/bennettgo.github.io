{
  title: 'SuccessFactors',

  secure_tunnel: true,

  connection: {
    fields: [
      {
        name: 'authentication',
        optional: false,
        control_type: 'select',
        pick_list: [
          %w[Basic basic],
          %w[Oauth2 oauth2]
        ]
      },
      {
        name: 'company',
        label: 'Company ID',
        optional: false
      },
      {
        name: 'user_id',
        optional: false,
        hint: 'SAP SuccessFactors user ID'
      },
      {
        ngIf: 'input.authentication == "basic"',
        name: 'password',
        control_type: 'password',
        optional: false
      },
      {
        ngIf: 'input.authentication == "oauth2"',
        name: 'client_id',
        optional: false,
        hint: 'OAuth client id. This is the API Key that was generated in API Center.'
      },
      {
        ngIf: 'input.authentication == "oauth2"',
        name: 'private_key',
        control_type: 'password',
        multiline: true,
        optional: false,
        hint: 'The X.509 private key used to sign SAML assertion. It can be the' \
        ' private key of a self-signed X.509 certificate or the private key of an X.509 ' \
        'certificate generated by SAP SuccessFactors. <b>Private key</b> is a BASE64-encoded ' \
        'string enclosed between -----BEGIN ENCRYPTED PRIVATE KEY----- and ----- END ' \
        'END ENCRYPTED PRIVATE KEY-----. Enter only the enclosed string without the beginning' \
        ' and ending lines. Otherwise, an error occurs.'
      },
      {
        name: 'environment',
        optional: false,
        control_type: 'select',
        pick_list: [
          ['DC2 Production', 'https://api2.successfactors.eu'],
          ['DC2 SalesDemo', 'https://apisalesdemo2.successfactors.eu'],
          ['DC2 Preview', 'https://api2preview.sapsf.eu'],
          ['DC4 Production', 'https://api4.successfactors.com'],
          ['DC4 Production', 'https://api4.successfactors.com'],
          ['DC4 SalesDemo', 'https://apisalesdemo4.successfactors.com'],
          ['DC4 Preview', 'https://api4preview.sapsf.com'],
          ['DC8 Production', 'https://api8.successfactors.com'],
          ['DC8 SalesDemo', 'https://apisalesdemo8.successfactors.com'],
          ['DC8 Preview', 'https://api8preview.sapsf.com'],
          ['DC10 Production', 'https://api10.successfactors.com'],
          ['DC10 Preview', 'https://api10preview.sapsf.com'],
          ['DC12 Production', 'https://api012.successfactors.eu'],
          ['DC12 Rot', 'https://apirot.successfactors.eu'],
          ['Preview', 'https://api12preview.sapsf.eu'],
          ['DC15 Production', 'https://api15.sapsf.cn'],
          ['DC16 Production', 'https://api16.sapsf.eu'],
          ['DC17 Preview', 'https://api17preview.sapsf.com'],
          ['DC 17 Production', 'https://api17.sapsf.com'],
          ['DC18 Preview', 'https://api18preview.sapsf.com'],
          ['DC18 Production', 'https://api18.sapsf.com']
        ]
      }
    ],

    authorization: {
      type: 'custom_auth',

      acquire: lambda do |connection|
        if connection['authentication'] == 'oauth2'
          assertion = post("#{connection['environment']}/oauth/idp").
                      headers(Accept: '*/*').
                      payload(
                        client_id: connection['client_id'],
                        user_id: connection['user_id'],
                        token_url: "#{connection['environment']}/oauth/token",
                        private_key: connection['private_key']
                      ).
                      request_format_www_form_urlencoded.
                      response_format_raw
          response = post("#{connection['environment']}/oauth/token").
                     payload(
                       client_id: connection['client_id'],
                       grant_type: 'urn:ietf:params:oauth:grant-type:saml2-bearer',
                       company_id: connection['company'],
                       assertion: assertion
                     ).request_format_www_form_urlencoded
          {
            access_token: response['access_token']
          }
        else
          { token: "#{connection['user_id']}@#{connection['company']}:#{connection['password']}".
            encode_base64 }
        end
      end,
      # NOTE for Oauth2
      # Add 400 in refresh_on block, if you are gettting 400 error while establishing connection
      refresh_on: [401, 403],

      apply: lambda do |connection|
        if connection['authentication'] == 'oauth2'
          headers(Authorization: "Bearer #{connection['access_token']}")
        else
          headers(Authorization: "Basic #{connection['token']}")
        end
      end
    },

    base_uri: lambda do |connection|
      connection['environment']
    end
  },

  test: lambda { |_connection|
    get('/odata/v2/User?$top=1')
  },

  object_definitions: {
    create_object_output: {
      fields: lambda do |_connection, config|
        associations = config['associations']&.split("\n")
        object_name = associations&.map do |association|
          association.split('-')[1]
        end
        final_schema = []
        obj = object_name.present? ? "#{config['object_name']},#{object_name.join(',')}" : config['object_name']
        call('get_metadata', object_name: obj)&.
          dig('edmx:Edmx', 0, 'edmx:DataServices', 0, 'Schema', 1, 'EntityType')&.
          each_with_index do |metadata, index|
          key_columns = call('object_key', metadata: metadata)
          schema = call('generate_schema',
                        metadata: metadata,
                        object_name: config['object_name'],
                        key_columns: key_columns,
                        type: '@visible')
          final_schema = schema if index == 0

          if object_name&.include?(metadata['@Name'])
            final_schema&.concat(call('generate_association_create_object',
                                      metadata: metadata, associations: associations,
                                      schema: schema))
          end
        end
        final_schema
      end
    },

    object_output: {
      fields: lambda do |_connection, config|
        associations = config['associations']&.split("\n")
        object_name = associations&.map do |association|
          association.split('-')[1]
        end
        final_schema = []
        obj = object_name.present? ? "#{config['object_name']},#{object_name.join(',')}" : config['object_name']
        call('get_metadata', object_name: obj)&.
          dig('edmx:Edmx', 0, 'edmx:DataServices', 0, 'Schema', 1, 'EntityType')&.
          each_with_index do |metadata, index|
            key_columns = call('object_key', metadata: metadata)
            schema = call('generate_schema',
                          metadata: metadata,
                          object_name: config['object_name'],
                          key_columns: key_columns,
                          type: '@visible')
            final_schema = schema if index == 0
            if object_name&.include?(metadata['@Name'])
              final_schema.concat(call('generate_association_output',
                                       metadata: metadata, associations: associations,
                                       schema: schema))
            end
          end
        final_schema
      end
    },

    object_create: {
      fields: lambda do |_connection, config|
        associations = config['associations']&.split("\n")
        object_name = associations&.map do |association|
          association.split('-')[1]
        end
        final_schema = []
        obj = object_name.present? ? "#{config['object_name']},#{object_name.join(',')}" : config['object_name']
        call('get_metadata', object_name: obj)&.
          dig('edmx:Edmx', 0, 'edmx:DataServices', 0, 'Schema', 1, 'EntityType')&.
          each_with_index do |metadata, index|
            key_columns = call('object_key', metadata: metadata)
            schema = call('generate_schema',
                          metadata: metadata,
                          object_name: config['object_name'],
                          key_columns: key_columns,
                          type: '@creatable',
                          associations: associations)

            final_schema = schema if index == 0

            if object_name&.include?(metadata['@Name'])
              final_schema&.concat(call('generate_association',
                                        metadata: metadata, associations: associations,
                                        schema: schema))
            end
          end
        final_schema
      end
    },

    object_update: {
      fields: lambda do |_connection, config|
        metadata = call('get_metadata', object_name: config['object_name'])&.
                     dig('edmx:Edmx', 0, 'edmx:DataServices', 0, 'Schema', 1, 'EntityType', 0)
        key_columns = call('object_key', metadata: metadata)
        call('generate_schema',
             metadata: metadata,
             object_name: config['object_name'],
             key_columns: key_columns,
             type: '@updatable')
      end
    },

    object_upsert: {
      fields: lambda do |_connection, config|
        metadata = call('get_metadata', object_name: config['object_name'])&.
                     dig('edmx:Edmx', 0, 'edmx:DataServices', 0, 'Schema', 1, 'EntityType', 0)
        key_columns = call('object_key', metadata: metadata)
        call('generate_schema',
             metadata: metadata,
             object_name: config['object_name'],
             key_columns: key_columns,
             type: '@upsertable')
      end
    },

    object_get: {
      fields: lambda do |_connection, config|
        metadata = call('get_metadata', object_name: config['object_name'])&.
                     dig('edmx:Edmx', 0, 'edmx:DataServices', 0, 'Schema', 1, 'EntityType', 0)
        key_columns = call('object_key', metadata: metadata)
        call('generate_schema',
             metadata: metadata,
             object_name: config['object_name'],
             key_columns: key_columns,
             type: '@filterable')&.select { |k| key_columns&.include?(k[:name]) }
      end
    },

    object_filter: {
      fields: lambda do |_connection, config|
        metadata = call('get_metadata', object_name: config['object_name'])&.
                     dig('edmx:Edmx', 0, 'edmx:DataServices', 0, 'Schema', 1, 'EntityType', 0)
        call('generate_schema',
             metadata: metadata,
             object_name: config['object_name'],
             type: '@filterable')
      end
    },

    option_labels: {
      fields: lambda do
        [
          { name: 'optionId' },
          { name: 'locale' },
          { name: 'id' },
          { name: 'label' }
        ]
      end
    },
    search_criteria: {
      fields: lambda do |_connection, _|
        [
          { name: 'select', label: 'fields' },
          { name: 'expand' },
          { name: 'filter' },
          { name: 'top', label: 'e.g. $top=5, The first 5 Product Entries ' \
            'returned' },
          { name: 'orderby', hint: 'e.g. Rating asc' }
        ]
      end
    },

    custom_action_input: {
      fields: lambda do |connection, config_fields|
        verb = config_fields['verb']
        input_schema = parse_json(config_fields.dig('input', 'schema') || '[]')
        data_props =
          input_schema.map do |field|
            if config_fields['request_type'] == 'multipart' &&
               field['binary_content'] == 'true'
              field['type'] = 'object'
              field['properties'] = [
                { name: 'file_content', optional: false },
                {
                  name: 'content_type',
                  default: 'text/plain',
                  sticky: true
                },
                { name: 'original_filename', sticky: true }
              ]
            end
            field
          end
        data_props = call('make_schema_builder_fields_sticky', data_props)
        input_data =
          if input_schema.present?
            if input_schema.dig(0, 'type') == 'array' &&
               input_schema.dig(0, 'details', 'fake_array')
              {
                name: 'data',
                type: 'array',
                of: 'object',
                properties: data_props.dig(0, 'properties')
              }
            else
              { name: 'data', type: 'object', properties: data_props }
            end
          end

        [
          {
            name: 'path',
            hint: 'Base URI is <b>' \
            "#{connection['environment']}" \
            '</b> - path will be appended to this URI. Use absolute URI to ' \
            'override this base URI.',
            optional: false
          },
          if %w[post put patch].include?(verb)
            {
              name: 'request_type',
              default: 'json',
              sticky: true,
              extends_schema: true,
              control_type: 'select',
              pick_list: [
                ['JSON request body', 'json'],
                ['URL encoded form', 'url_encoded_form'],
                ['Mutipart form', 'multipart'],
                ['Raw request body', 'raw']
              ]
            }
          end,
          {
            name: 'response_type',
            default: 'json',
            sticky: false,
            extends_schema: true,
            control_type: 'select',
            pick_list: [['JSON response', 'json'], ['Raw response', 'raw']]
          },
          if %w[get options delete].include?(verb)
            {
              name: 'input',
              label: 'Request URL parameters',
              sticky: true,
              add_field_label: 'Add URL parameter',
              control_type: 'form-schema-builder',
              type: 'object',
              properties: [
                {
                  name: 'schema',
                  sticky: input_schema.blank?,
                  extends_schema: true
                },
                input_data
              ].compact
            }
          else
            {
              name: 'input',
              label: 'Request body parameters',
              sticky: true,
              type: 'object',
              properties:
                if config_fields['request_type'] == 'raw'
                  [{
                    name: 'data',
                    sticky: true,
                    control_type: 'text-area',
                    type: 'string'
                  }]
                else
                  [
                    {
                      name: 'schema',
                      sticky: input_schema.blank?,
                      extends_schema: true,
                      schema_neutral: true,
                      control_type: 'schema-designer',
                      sample_data_type: 'json_input',
                      custom_properties:
                        if config_fields['request_type'] == 'multipart'
                          [{
                            name: 'binary_content',
                            label: 'File attachment',
                            default: false,
                            optional: true,
                            sticky: true,
                            render_input: 'boolean_conversion',
                            parse_output: 'boolean_conversion',
                            control_type: 'checkbox',
                            type: 'boolean'
                          }]
                        end
                    },
                    input_data
                  ].compact
                end
            }
          end,
          {
            name: 'request_headers',
            sticky: false,
            extends_schema: true,
            control_type: 'key_value',
            empty_list_title: 'Does this HTTP request require headers?',
            empty_list_text: 'Refer to the API documentation and add ' \
            'required headers to this HTTP request',
            item_label: 'Header',
            type: 'array',
            of: 'object',
            properties: [{ name: 'key' }, { name: 'value' }]
          },
          unless config_fields['response_type'] == 'raw'
            {
              name: 'output',
              label: 'Response body',
              sticky: true,
              extends_schema: true,
              schema_neutral: true,
              control_type: 'schema-designer',
              sample_data_type: 'json_input'
            }
          end,
          {
            name: 'response_headers',
            sticky: false,
            extends_schema: true,
            schema_neutral: true,
            control_type: 'schema-designer',
            sample_data_type: 'json_input'
          }
        ].compact
      end
    },

    custom_action_output: {
      fields: lambda do |_connection, config_fields|
        response_body = { name: 'body' }

        [
          if config_fields['response_type'] == 'raw'
            response_body
          elsif (output = config_fields['output'])
            output_schema = call('format_schema', parse_json(output))
            if output_schema.dig(0, 'type') == 'array' &&
               output_schema.dig(0, 'details', 'fake_array')
              response_body[:type] = 'array'
              response_body[:properties] = output_schema.dig(0, 'properties')
            else
              response_body[:type] = 'object'
              response_body[:properties] = output_schema
            end

            response_body
          end,
          if (headers = config_fields['response_headers'])
            header_props = parse_json(headers)&.map do |field|
              if field[:name].present?
                field[:name] = field[:name].gsub(/\W/, '_').downcase
              elsif field['name'].present?
                field['name'] = field['name'].gsub(/\W/, '_').downcase
              end
              field
            end

            { name: 'headers', type: 'object', properties: header_props }
          end
        ].compact
      end
    }
  },

  methods: {
    get_entity_set: lambda do
      get('/odata/v2/$metadata').response_format_xml.
        dig('edmx:Edmx', 0, 'edmx:DataServices', 0, 'Schema', 0,
            'EntityContainer', 0, 'EntitySet')
    end,

    get_closure_value: lambda do |input|
      output = {}
      if input[:flag]
        output['skip'] = input[:skip] + input[:page]
      else
        output['last_modified_date'] =
          if input[:obj].present?
            input[:obj].last['lastModifiedDateTime']&.to_time&.utc&.iso8601
          else
            now.to_time.utc.iso8601
          end
        output['skip'] = 0
      end
      output
    end,

    date_time_conversion: lambda do |input|
      if input[:e_i_s].first&.[]('type') == 'array'
        input[:e_i_s].first&.[]('properties')&.map do |field|
          if field['type'] == 'date_time'
            input[:value].each do |val|
              val[field['name']] =
                "\/Date(" + (val[field['name']]&.to_time.to_i * 1000).to_s + ")\/"
            end
          end
        end
      else
        input[:e_i_s].first&.[]('properties')&.map do |field|
          if field['type'] == 'date_time'
            input[:value][field['name']] =
              "\/Date(" + (input[:value][field['name']]&.to_time.to_i * 1000).to_s + ")\/"
          end
        end
      end
      input[:value]
    end,

    input_parser: lambda do |input|
      input[:input].map do |key, value|
        if input[:date_fields].include?(key)
          if value.present?
            date_time = value.to_time.to_i * 1000
            { key => "\/Date(" + date_time.to_s + ")\/" }
          else
            { key => value }
          end
        elsif input[:association].present? && input[:association].include?(key) && value.present?
          asso_e_i_s = input[:e_i_s].select { |field| field['name'] == key }
          { key => call('date_time_conversion', e_i_s: asso_e_i_s, value: value) }
        else
          { key => value }
        end
      end.inject(:merge)
    end,

    output_parser: lambda do |input|
      input.delete(:e_o_s)&.each do |data|
        if data['type'] == 'date_time'
          if input.dig(:output, data['name']).present?
            input[:output][data['name']] =
              (input.dig(:output, data['name']).scan(/[-]*\d+/)[0].to_i / 1000).to_time.utc
          end
        end
      end
      input[:output]
    end,

    output_parse_trigger: lambda do |input|
      input[:obj].map do |key, value|
        if input[:date_fields].include?(key)
          if value.present?
            date_time = value.scan(/[-]*\d+/)[0]
            { key => (date_time.to_i / 1000).to_i.to_time.utc }
          else
            { key => value }
          end
        elsif input[:associations]&.include?(key) && value.present?
          asso_e_o_s = input[:e_o_s]&.first&.[]('properties')&.
                       select { |field| field['name'] == key }&.first&.[]('properties')
          if value['results'].present?
            value['results'] =
              value['results'].map do |asso_obj|
                call('output_parser', output: asso_obj,
                                      e_o_s: asso_e_o_s&.first&.[]('properties'))
              end
            { key => value }
          else
            { key => call('output_parser', output: value, e_o_s: asso_e_o_s) }
          end
        else
          { key => value }
        end
      end.inject(:merge)
    end,

    generate_params: lambda do |input|
      {
        '$filter': "lastModifiedDateTime gt datetimeoffset'#{input[:since]}'",
        '$orderby': 'lastModifiedDateTime asc', '$skip': input[:skip],
        '$top': input[:limit], '$inlinecount': 'allpages'
      }
    end,

    generate_closure: lambda do |input|
      {
        'object_name' => input[:object_name],
        'last_modified_datetime' => input[:last_updated_since],
        'key_column' => input[:key_column],
        'date_fields' => input[:date_fields],
        'skip' => input[:skip]
      }
    end,

    generate_association: lambda do |input|
      schema = []
      input[:associations]&.each do |obj|
        if obj.include?(input.dig(:metadata, '@Name'))
          object_details = obj.split('-')
          if object_details&.last == 'OneToMany'
            schema << { name: object_details.first,
                        type: 'array', of: 'object',
                        properties: input[:schema] }
          else
            schema << { name: object_details.first,
                        type: 'object',
                        properties: input[:schema] }
          end
        end
      end
      schema
    end,

    generate_association_create_object: lambda do |input|
      schema = []
      input[:associations]&.each do |obj|
        if obj.include?(input.dig(:metadata, '@Name'))
          object_details = obj.split('-')
          schema << { name: object_details.first,
                      type: 'object',
                      properties: input[:schema] }
        end
      end
      schema
    end,

    generate_association_output: lambda do |input|
      schema = []
      input[:associations]&.each do |obj|
        if obj.include?(input.dig(:metadata, '@Name'))
          object_details = obj.split('-')
          if object_details&.last == 'OneToMany'
            schema << { name: object_details.first,
                        type: 'object',
                        properties: [
                          name: 'results',
                          type: 'array', of: 'object',
                          properties: input[:schema]
                        ] }
          else
            schema << { name: object_details.first,
                        type: 'object',
                        properties: input[:schema] }
          end
        end
      end
      schema
    end,

    date_fields: lambda do |input|
      get("/odata/v2/#{input[:object_name]}/$metadata").
        response_format_xml.
        dig('edmx:Edmx', 0, 'edmx:DataServices', 0, 'Schema', 1, 'EntityType', 0, 'Property')&.
        select do |field|
          ['Edm.DateTime', 'Edm.DateTimeOffset'].include?(field['@Type'])
        end&.map do |e|
          e['@Name']
        end
    end,

    get_metadata: lambda do |input|
      get("/odata/v2/#{input[:object_name]}/$metadata").response_format_xml
    end,

    object_key: lambda do |input|
      input[:metadata]&.dig('Key', 0, 'PropertyRef')&.pluck('@Name')
    end,
    # generates pick list options for the given PicklistId
    get_pick_list_options: lambda do |input|
      picklist_options = get("/odata/v2/Picklist('#{input[:pick_list_id].gsub(' ', '%20')}')/" \
                             'picklistOptions').
                         params('$format': 'json').
                         headers('Accept': 'application/json', 'Content-Type': 'application/json').
                         after_error_response(/.*/) do |_code, body, _header, message|
                           if body&.include?('COE_RECORD_NOT_FOUND')
                             []
                           else
                             error("#{message}: #{body}")
                           end
                         end
      if picklist_options.present?
        picklist_options.dig('d', 'results')&.
          select { |o| o['status'] == 'ACTIVE' }&.map do |option|
            ["#{option['externalCode'].labelize} -  #{option['id']}", option['id']]
            # [option['id'], option['externalCode'].split('_')[1..-1].join(' ')]
          end
      else
        []
      end
    end,
    # generates schema for the objects w.r.t operations.
    generate_schema: lambda do |input|
      key_columns = input[:key_columns] || []
      input[:metadata]&.dig('Property')&.
          select { |field| field[input[:type]] == 'true' }&.map do |o|
            optional =
              if input[:associations].present?
                key_columns.include?(o['@Name']) ? false : true
              else
                if (input[:type] == '@updatable' || input[:type] == '@upsertable') && key_columns.include?(o['@Name'])
                  false
                elsif input[:object_name] == 'User' && input[:type] == '@updatable' && o['@Name'] == 'username'
                  false
                elsif input[:type] == '@creatable' || input[:type] == '@updatable'
                  o['@required'].include?('false')
                else
                  true
                end
              end
            description =
              if input[:type] == '@upsertable' && key_columns.include?(o['@Name'])
                if key_columns.include?(o['@Name'])
                  'Key column, updates if exists othewise create new one'
                elsif o['@required'].include?('true')
                  'Required '
                end
              end || nil
            sticky = input[:type] == '@upsertable' && o['@required'].include?('true') ? true : false

            case o['@Type']
            when 'Edm.String'
              # switch if all the picklists are configured correctly in SF
              if o['@picklist'].present?
                options =
                  call('get_pick_list_options', pick_list_id: o['@picklist'])&.presence || []
                {
                  name: o['@Name'], control_type: 'select',
                  pick_list: options,
                  optional: optional,
                  label: o['@label'].labelize,
                  hint: 'Pick list option id is suffixed with externalCode',
                  toggle_hint: 'Select from list',
                  toggle_field: {
                    toggle_hint: 'Enter custom value',
                    name: o['@Name'], type: 'string',
                    control_type: 'text',
                    label: o['@label'].labelize,
                    optional: optional
                  }
                }
              else
                {
                  name: o['@Name'], type: 'string',
                  optional: optional,
                  sticky: sticky,
                  hint: description,
                  label: o['@label'].labelize
                }
              end
            when 'Edm.Boolean'
              {
                name: o['@Name'], type: 'boolean',
                control_type: 'checkbox',
                render_input: 'boolean_conversion',
                parse_output: 'boolean_conversion',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize,
                toggle_hint: 'Select from list',
                toggle_field: {
                  toggle_hint: 'Enter custom value',
                  name: o['@Name'], type: 'boolean',
                  control_type: 'text',
                  render_input: 'boolean_conversion',
                  parse_output: 'boolean_conversion',
                  label: o['@label'].labelize,
                  optional: optional
                }
              }
            when 'Edm.Byte'
              {
                name: o['@Name'], type: 'integer',
                control_type: 'number',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize
              }
            when 'Edm.DateTime'
              {
                name: o['@Name'], type: 'date_time',
                control_type: 'date_time',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize
              }
            when 'Edm.Decimal'
              {
                name: o['@Name'], type: 'number',
                control_type: 'number',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize
              }
            when 'Edm.Double'
              {
                name: o['@Name'], type: 'number',
                control_type: 'number',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize
              }
            when 'Edm.Single'
              {
                name: o['@Name'], type: 'number',
                control_type: 'number',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize
              }
            when 'Edm.Guid'
              {
                name: o['@Name'], type: 'string',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize
              }
            when 'Edm.Int16'
              {
                name: o['@Name'], type: 'integer',
                control_type: 'number',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize
              }
            when 'Edm.Int32'
              {
                name: o['@Name'], type: 'integer',
                control_type: 'number',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize
              }
            when 'Edm.Int64'
              {
                name: o['@Name'], type: 'integer',
                control_type: 'number',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize
              }
            when 'Edm.SByte'
              {
                name: o['@Name'], type: 'integer',
                control_type: 'number',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize
              }
            when 'Edm.Time'
              {
                name: o['@Name'], type: 'string',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize
              }
            when 'Edm.DateTimeOffset'
              {
                name: o['@Name'], type: 'timestamp',
                control_type: 'date_time',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize
              }
            else
              {
                name: o['@Name'], type: 'string',
                optional: optional,
                sticky: sticky,
                hint: description,
                label: o['@label'].labelize
              }
            end
          end&.compact&.presence || [{}]
    end,
    ##############################################################
    # Helper methods                                             #
    ##############################################################
    # This method is for Custom action
    make_schema_builder_fields_sticky: lambda do |schema|
      schema.map do |field|
        if field['properties'].present?
          field['properties'] = call('make_schema_builder_fields_sticky',
                                     field['properties'])
        end
        field['sticky'] = true

        field
      end
    end,

    # Formats input/output schema to replace any special characters in name,
    # without changing other attributes (method required for custom action)
    format_schema: lambda do |input|
      input&.map do |field|
        if (props = field[:properties])
          field[:properties] = call('format_schema', props)
        elsif (props = field['properties'])
          field['properties'] = call('format_schema', props)
        end
        if (name = field[:name])
          field[:label] = field[:label].presence || name.labelize
          field[:name] = name
                         .gsub(/\W/) { |spl_chr| "__#{spl_chr.encode_hex}__" }
        elsif (name = field['name'])
          field['label'] = field['label'].presence || name.labelize
          field['name'] = name
                          .gsub(/\W/) { |spl_chr| "__#{spl_chr.encode_hex}__" }
        end

        field
      end
    end,

    # Formats payload to inject any special characters that previously removed
    format_payload: lambda do |payload|
      if payload.is_a?(Array)
        payload.map do |array_value|
          call('format_payload', array_value)
        end
      elsif payload.is_a?(Hash)
        payload.each_with_object({}) do |(key, value), hash|
          key = key.gsub(/__\w+__/) do |string|
            string.gsub(/__/, '').decode_hex.as_utf8
          end
          if value.is_a?(Array) || value.is_a?(Hash)
            value = call('format_payload', value)
          end
          hash[key] = value
        end
      end
    end,

    # Formats response to replace any special characters with valid strings
    # (method required for custom action)
    format_response: lambda do |response|
      response = response&.compact unless response.is_a?(String) || response
      if response.is_a?(Array)
        response.map do |array_value|
          call('format_response', array_value)
        end
      elsif response.is_a?(Hash)
        response.each_with_object({}) do |(key, value), hash|
          key = key.gsub(/\W/) { |spl_chr| "__#{spl_chr.encode_hex}__" }
          if value.is_a?(Array) || value.is_a?(Hash)
            value = call('format_response', value)
          end
          hash[key] = value
        end
      else
        response
      end
    end
  },

  actions: {

    custom_action: {
      subtitle: 'Build your own SuccessFactors action with a HTTP request',

      description: lambda do |object_value, _object_label|
        "<span class='provider'>" \
        "#{object_value[:action_name] || 'Custom action'}</span> in " \
        "<span class='provider'>SuccessFactors</span>"
      end,

      help: {
        body: 'Build your own SuccessFactors action with a HTTP request. ' \
        'The request will be authorized with your SuccessFactors connection.',
        learn_more_url: 'https://help.sap.com/viewer/b2b06831c2cb4d5facd1dfde49a7' \
        'aab5/2005/en-US/a6f7a6e540b7409ba550bf070b73a5a5.html',
        learn_more_text: 'SuccessFactors API documentation'
      },

      config_fields: [
        {
          name: 'action_name',
          hint: "Give this action you're building a descriptive name, e.g. " \
          'create record, get record',
          default: 'Custom action',
          optional: false,
          schema_neutral: true
        },
        {
          name: 'verb',
          label: 'Method',
          hint: 'Select HTTP method of the request',
          optional: false,
          control_type: 'select',
          pick_list: %w[get post put patch options delete]
            .map { |verb| [verb.upcase, verb] }
        }
      ],

      input_fields: lambda do |object_definition|
        object_definition['custom_action_input']
      end,

      execute: lambda do |_connection, input|
        verb = input['verb']
        if %w[get post put patch options delete].exclude?(verb)
          error("#{verb.upcase} not supported")
        end
        path = input['path']
        data = input.dig('input', 'data') || {}
        if input['request_type'] == 'multipart'
          data = data.each_with_object({}) do |(key, val), hash|
            hash[key] = if val.is_a?(Hash)
                          [val[:file_content],
                           val[:content_type],
                           val[:original_filename]]
                        else
                          val
                        end
          end
        end
        request_headers = input['request_headers']
          &.each_with_object({}) do |item, hash|
          hash[item['key']] = item['value']
        end || {}
        request = case verb
                  when 'get'
                    get(path, data)
                  when 'post'
                    if input['request_type'] == 'raw'
                      post(path).request_body(data)
                    else
                      post(path, data)
                    end
                  when 'put'
                    if input['request_type'] == 'raw'
                      put(path).request_body(data)
                    else
                      put(path, data)
                    end
                  when 'patch'
                    if input['request_type'] == 'raw'
                      patch(path).request_body(data)
                    else
                      patch(path, data)
                    end
                  when 'options'
                    options(path, data)
                  when 'delete'
                    delete(path, data)
                  end.headers(request_headers)
        request = case input['request_type']
                  when 'url_encoded_form'
                    request.request_format_www_form_urlencoded
                  when 'multipart'
                    request.request_format_multipart_form
                  else
                    request
                  end
        response =
          if input['response_type'] == 'raw'
            request.response_format_raw
          else
            request
          end
          .after_error_response(/.*/) do |code, body, headers, message|
            error({ code: code, message: message, body: body, headers: headers }
              .to_json)
          end

        response.after_response do |_code, res_body, res_headers|
          {
            body: res_body ? call('format_response', res_body) : nil,
            headers: res_headers
          }
        end
      end,

      output_fields: lambda do |object_definition|
        object_definition['custom_action_output']
      end
    },
    search_object: {
      title: 'Search records',
      subtitle: 'Retrieve a list of records, e.g. users, that match your search criteria',
      description: lambda do |_connection, pick_list|
        "Search for <span class='provider'> " \
        "#{pick_list['object_name'] || 'records'}</span>" \
          " in <span class='provider'>SuccessFactors</span>"
      end,
      help: 'The Search records action returns results that match all your search criteria.',
      config_fields: [
        {
          name: 'object_name', control_type: 'select',
          pick_list: 'entity_set',
          label: 'Search for',
          hint: 'Select the SuccessFactors object to search for, then specify at least one field to match',
          optional: false,
          toggle_hint: 'Select Object',
          toggle_field: {
            name: 'object_name',
            type: 'string',
            control_type: 'text',
            label: 'Search for',
            toggle_hint: 'Use Entityset name',
            hint: 'Provide any SuccessFactors object(Entityset name) to search for, then specify at least one field to match'
          }
        },
        {
          name: 'associations', control_type: 'text-area',
          label: 'Associations',
          optional: true,
          sticky: true,
          hint: <<-HINT
                Type in the details of your association below (one per line).
                This will generate additional input fields below. for example:
                <b>cust_cost_center-FOCostCenter-OneToMany</b> where <b>cust_cost_center</b>
                would be your <b>Property Name</b>, <b>FOCostCenter</b> would be your
                <b>Type</b>, <b>OneToMany</b> would be your <b>Relationship type</b>.
          HINT
        }
      ],

      input_fields: lambda do |object_definitions|
        object_definitions['object_filter']
      end,

      execute: lambda do |_connection, input, _, e_o_s|
        object_name = input.delete('object_name')
        associations = input.delete('associations')
        association_string = associations&.split("\n")&.map do |obj|
          obj.split('-').first
        end&.join(',')
        error('Provide at least one search criteria') if input.blank?
        date_fields = call('date_fields', object_name: object_name)
        filter_params = []
        filter_string = input.map do |key, val|
          if val.present?
            filter_params << if date_fields.include?(key)
                               (key + " eq datetime'" + val.utc.iso8601 + "'")
                             else
                               (key + " eq '" + val + "'")
                             end
          end
        end.smart_join(' and ')
        url = association_string.present? ? "&$expand=#{association_string}" : ''
        object = get("/odata/v2/#{object_name}?$filter=#{filter_string}" + url).
                 after_error_response(/.*/) do |_code, body, _header, message|
                   error("#{message}: #{body}")
                 end.dig('d', 'results')
        final_objects = object&.map do |obj|
          call('output_parse_trigger', obj: obj, date_fields: date_fields,
                                       associations: associations, e_o_s: e_o_s)
        end
        { objects: final_objects }
      end,

      output_fields: lambda do |object_definitions|
        [
          { name: 'objects', type: 'array', of: 'object',
            properties: object_definitions['object_output'] }
        ]
      end,

      sample_output: lambda do |_connection, input|
        date_fields = call('date_fields', object_name: input['object_name'])
        object = get("/odata/v2/#{input['object_name']}").
                 params('$top': 1).dig('d', 'results', 0)
        {
          objects: call('output_parse_trigger', obj: object, date_fields: date_fields) || {}
        }
      end
    },

    advance_search_object: {
      title: 'Search records using Odata query',
      subtitle: 'Retrieve a list of records, e.g. users, that match Odata query criteria',
      description: lambda do |_connection, pick_list|
        "Search for <span class='provider'> " \
        "#{pick_list['object_name'] || 'records'}</span>" \
          " using Odata query in <span class='provider'>SuccessFactors</span>"
      end,

      help: {
        body: 'EC API provides parameters asOfDate, fromDate, and toDate for ' \
          'effective-dated entities so that you can query the history or future' \
          ' records of an entity.<br> There are two ways to query effective-dated' \
          ' entities. You can use one of the following ways but not both in one action.<br>' \
          '● asOfDate query: Returns one single effective record as of the specified date.' \
          ' If no asOfDate is specified, the OData API uses the current date of the' \
          ' query as asOfDate. For records that allow multiple changes per day, the ' \
          ' record with the highest sequence number is returned.<br> ' \
          '● fromDate and toDate query (date range query): Returns records effective' \
          ' between the specified date range. With records that allow multiple changes' \
          ' per day, the record with the highest sequence number is returned. You can' \
          ' use one or both of the parameters in one query',
        learn_more_url: 'https://help.sap.com/viewer/b2b06831c2cb4d5facd1dfde49a7aab5' \
          '/2005/en-US/95fbd901727d4f25b740a0c69f01b1be.html',
        learn_more_text: 'SAP SuccessFactors API documentation'
      },

      config_fields: [
        {
          name: 'object_name', control_type: 'select',
          pick_list: 'entity_set',
          label: 'Search for',
          hint: 'Select the SuccessFactors object to search for, then specify query',
          optional: false,
          toggle_hint: 'Select Object',
          toggle_field: {
            name: 'object_name',
            type: 'string',
            control_type: 'text',
            label: 'Search for',
            toggle_hint: 'Use Entityset name',
            hint: 'Provide any SuccessFactors object(Entityset name) to search for'
          }
        },
        {
          name: 'associations', control_type: 'text-area',
          label: 'Associations',
          optional: true,
          sticky: true,
          hint: <<-HINT
          Type in the details of your association below (one per line).
          This will generate additional input fields below. for example:
          <b>cust_cost_center-FOCostCenter-OneToMany</b> where <b>cust_cost_center</b>
          would be your <b>Property Name</b>, <b>FOCostCenter</b> would be your
          <b>Type</b>, <b>OneToMany</b> would be your <b>Relationship type</b>.
          HINT
        }
      ],
      input_fields: lambda do |_object_defintions|
        [
          {
            name: 'filter',
            control_type: 'text',
            label: 'Query',
            hint: 'Filter Condition which needs be used to filter, for e.g. ' \
            "effectiveStartDate eq datetime'2019-11-05T00:00:00' and externalCode eq 'rafObj5'.",
            optional: false
          },
          {
            name: 'select',
            label: 'Select fields',
            sticky: true,
            hint: 'Fields that needs to come in the response and not return all the other' \
            ' fields of the HRData. Provide fields separated by comma.' \
            '<b>userId, timeZone, email, country</b>'
          },
          { name: 'asOfDate', type: 'date' },
          { name: 'fromDate', type: 'date',
            hint: 'Returns records effective between the specified date range' },
          { name: 'toDate', type: 'date',
            hint: 'Returns records effective between the specified date range' },
          { name: 'top', type: 'integer',
            label: 'Page size',
            hint: 'Maximum number of records to be returned as part of the response.' \
            ' The Maximum limit is 1000.' },
          { name: 'skip', type: 'integer',
            label: 'Offset',
            hint: 'Skip the number of records and fetch from the number provided.' }
        ]
      end,

      execute: lambda do |_connection, input, _, e_o_s|
        object_name = input.delete('object_name')
        associations = input.delete('associations')
        association_string = associations&.split("\n")&.map do |obj|
          obj.split('-').first
        end&.join(',')
        date_fields = call('date_fields', object_name: object_name)
        query_params = {
          '$filter': input['filter'],
          '$expand': association_string,
          '$select': input['select'],
          'asOfDate': input['asOfDate'],
          'fromDate': input['fromDate'],
          'toDate': input['toDate'],
          '$top': input['top'] || 100,
          '$skip': input['skip'] || 0
        }.compact.to_param
        object = get("/odata/v2/#{object_name}", query_params).
                 after_error_response(/.*/) do |_code, body, _header, message|
                   error("#{message}: #{body}")
                 end.dig('d', 'results')
        final_objects = object&.map do |obj|
          call('output_parse_trigger', obj: obj, date_fields: date_fields,
                                       associations: associations, e_o_s: e_o_s)
        end
        { objects: final_objects }
      end,

      output_fields: lambda do |object_definitions|
        [
          { name: 'objects', type: 'array', of: 'object',
            properties: object_definitions['object_output'] }
        ]
      end,

      sample_output: lambda do |_connection, input|
        date_fields = call('date_fields', object_name: input['object_name'])
        object = get("/odata/v2/#{input['object_name']}").
                 params('$top': 1).dig('d', 'results', 0)
        {
          objects: call('output_parse_trigger', obj: object, date_fields: date_fields) || {}
        }
      end
    },

    create_object: {
      title: 'Create record',
      subtitle: 'Create a record, e.g. user, in SuccessFactors',
      description: lambda do |_connection, pick_list|
        "Create <span class='provider'> " \
        "#{pick_list['object_name'] || 'record'}</span>" \
          " in <span class='provider'>SuccessFactors</span>"
      end,
      config_fields: [
        {
          name: 'object_name', control_type: 'select',
          pick_list: 'entity_set',
          label: 'Object',
          hint: 'Select any SuccessFactors object, e.g. user',
          optional: false,
          toggle_hint: 'Select Object',
          toggle_field: {
            name: 'object_name',
            type: 'string',
            control_type: 'text',
            label: 'Object',
            toggle_hint: 'Use Entityset name',
            hint: 'Provide any SuccessFactors object(Entityset name), e.g. User.'
          }
        },
        {
          name: 'associations', control_type: 'text-area',
          label: 'Associations',
          optional: true,
          sticky: true,
          hint: <<-HINT
                Type in the details of your association below (one per line).
                This will generate additional input fields below. for example:
                <b>cust_cost_center-FOCostCenter-OneToMany</b> where <b>cust_cost_center</b>
                would be your <b>Property Name</b>, <b>FOCostCenter</b> would be your
                <b>Type</b>, <b>OneToMany</b> would be your <b>Relationship type</b>.
          HINT
        }
      ],

      input_fields: lambda do |object_definitions|
        object_definitions['object_create']
      end,

      execute: lambda do |_connection, input, e_i_s, e_o_s|
        object_name = input.delete('object_name')
        association = input.delete('associations')
        # set empployee id on User creation
        if object_name == 'User' && input['empId'].blank?
          employee_id = post('/odata/v2/generateNextPersonID?$format=json')&.
                        dig('d', 'GenerateNextPersonIDResponse', 'personID')
          input['empId'] = employee_id
        end
        date_fields = call('date_fields', object_name: object_name)
        payload = call('input_parser', input: input,
                                       date_fields: date_fields,
                                       association: association, e_i_s: e_i_s)
        output = post("/odata/v2/#{object_name}").payload(payload).
                 after_error_response(/.*/) do |_code, body, _header, message|
                   error("#{message}: #{body}")
                 end['d']
        association&.split("\n")&.each do |k|
          asso = k.split('-').first
          asso_e_o_s = e_o_s.select { |field| field['name'] == asso }.first&.[]('properties')
          output[asso] = call('output_parser', output: output[asso], e_o_s: asso_e_o_s)
        end
        call('output_parser', output: output, e_o_s: e_o_s)
      end,

      output_fields: lambda do |object_definitions|
        object_definitions['create_object_output']
      end,

      sample_output: lambda do |_connection, input|
        date_fields = call('date_fields', object_name: input['object_name'])
        object = get("/odata/v2/#{input['object_name']}").
                 params('$top': 1).dig('d', 'results', 0)
        call('output_parse_trigger', obj: object, date_fields: date_fields) || {}
      end
    },

    update_object: {
      title: 'Update record',
      subtitle: 'Update a record, e.g. user, in SuccessFactors',
      description: lambda do |_connection, pick_list|
        "Update <span class='provider'> " \
        "#{pick_list['object_name'] || 'record'}</span>" \
          " in <span class='provider'>SuccessFactors</span>"
      end,
      help: 'All property values in the entity either take the values ' \
        'provided in the request body or reset to their default value ' \
        'if no data is provided in the request.',

      config_fields: [
        {
          name: 'object_name', control_type: 'select',
          pick_list: 'entity_set',
          label: 'Object',
          hint: 'Select any SuccessFactors object, e.g. user',
          optional: false,
          toggle_hint: 'Select Object',
          toggle_field: {
            name: 'object_name',
            type: 'string',
            control_type: 'text',
            label: 'Object',
            toggle_hint: 'Use Entityset name',
            hint: 'Provide any SuccessFactors object(Entityset name), e.g. User.'
          }
        },
        {
          name: 'key_column', control_type: 'multiselect',
          delimiter: ',',
          pick_list: 'unique_keys',
          pick_list_params: { object_name: 'object_name' },
          label: 'Object unique key',
          hint: 'Select key column',
          optional: false,
          toggle_hint: 'Select key',
          toggle_field: {
            name: 'key_column',
            type: 'string',
            control_type: 'text',
            label: 'Object unique key column',
            toggle_hint: 'Use object unique column name',
            hint: 'Object key column - internal name'
          }
        }
      ],

      input_fields: lambda do |object_definitions|
        object_definitions['object_update']
      end,

      execute: lambda do |_connection, input, _, e_o_s|
        object_name = input.delete('object_name')
        key_column = input.delete('key_column')
        date_fields = call('date_fields', object_name: object_name)
        payload = call('input_parser', input: input, date_fields: date_fields)
        key_string = key_column.split(',').map do |k|
          date_fields.include?(k) ? "#{k}=datetime'#{input[k].utc.iso8601}'" : "#{k}='#{input[k]}'"
        end.join(',')
        payload[:__metadata] = {
          'uri': object_name + "(#{key_string})"
        }
        output = put("/odata/v2/#{object_name}(#{key_string})").
                 params('$format': 'json').
                 payload(payload.except(key_column)).
                 after_error_response(/.*/) do |_code, body, _header, message|
                   error("#{message}: #{body}")
                 end
        call('output_parser', output: output, e_o_s: e_o_s)
      end,

      # output_fields: lambda do |object_definitions|
      #   object_definitions['object_output']
      # end,

      sample_output: lambda do |_connection, input|
        date_fields = call('date_fields', object_name: input['object_name'])
        object = get("/odata/v2/#{input['object_name']}").
                 params('$top': 1).dig('d', 'results', 0)
        call('output_parse_trigger', obj: object, date_fields: date_fields) || {}
      end
    },

    merge_object: {
      title: 'Merge record',
      subtitle: 'Merge a record, e.g. user, in SuccessFactors',
      description: lambda do |_connection, pick_list|
        "Merge <span class='provider'> " \
        "#{pick_list['object_name'] || 'record'}</span>" \
          " in <span class='provider'>SuccessFactors</span>"
      end,
      help: 'Merge updates only the properties provided in the request ' \
        'body, and leaves the data not mentioned in the request body in ' \
        'its current state.',

      config_fields: [
        {
          name: 'object_name', control_type: 'select',
          pick_list: 'entity_set',
          label: 'Object',
          hint: 'Select any SuccessFactors object, e.g. user',
          optional: false,
          toggle_hint: 'Select Object',
          toggle_field: {
            name: 'object_name',
            type: 'string',
            control_type: 'text',
            label: 'Object',
            toggle_hint: 'Use Entityset name',
            hint: 'Provide any SuccessFactors object(Entityset name), e.g. User.'
          }
        },
        {
          name: 'key_column', control_type: 'multiselect',
          delimiter: ',',
          pick_list: 'unique_keys',
          pick_list_params: { object_name: 'object_name' },
          label: 'Object unique key',
          hint: 'Select key column',
          optional: false,
          toggle_hint: 'Select key',
          toggle_field: {
            name: 'key_column',
            type: 'string',
            control_type: 'text',
            label: 'Object unique key column',
            toggle_hint: 'Use object unique column name',
            hint: 'Object key column - internal name'
          }
        }
      ],

      input_fields: lambda do |object_definitions|
        object_definitions['object_update']
      end,

      execute: lambda do |_connection, input, _, e_o_s|
        object_name = input.delete('object_name')
        key_column = input.delete('key_column')
        date_fields = call(:date_fields, object_name: object_name)
        payload = call('input_parser', input: input, date_fields: date_fields)
        key_string = key_column.split(',').map do |k|
          date_fields.include?(k) ? "#{k}=datetime'#{input[k].utc.iso8601}'" : "#{k}='#{input[k]}'"
        end.join(',')
        output = post("/odata/v2/#{object_name}(" + key_string + ')').
                 params('$format': 'json').
                 headers('x-http-method': 'MERGE').
                 payload(payload).
                 after_error_response(/.*/) do |_code, body, _header, message|
                   error("#{message}: #{body}")
                 end
        call('output_parser', output: output, e_o_s: e_o_s)
      end,

      # output_fields: lambda do |object_definitions|
      #   object_definitions['object_output']
      # end,

      sample_output: lambda do |_connection, input|
        date_fields = call(:date_fields, object_name: input['object_name'])
        object = get("/odata/v2/#{input['object_name']}").
                 params('$top': 1).dig('d', 'results', 0)
        call('output_parse_trigger', obj: object, date_fields: date_fields) || {}
      end
    },

    upsert_object: {
      title: 'Upsert records',
      subtitle: "Create a record if it doesn't already exists, otherwise, update existing record",
      description: lambda do |_connection, pick_list|
        "Upsert <span class='provider'> " \
        "#{pick_list['object_name'] || 'records'}</span>" \
          " in <span class='provider'>SuccessFactors</span>"
      end,

      help: 'Search for Person in Salesforce by a specified field (primary key). ' \
      'If found, update it with the data being provided to the action. If not found,' \
      ' create it with the data being provided to the action',
      config_fields: [
        {
          name: 'object_name', control_type: 'select',
          pick_list: 'entity_set',
          label: 'Object',
          hint: 'Select any SuccessFactors object, e.g. user',
          optional: false,
          toggle_hint: 'Select Object',
          toggle_field: {
            name: 'object_name',
            type: 'string',
            control_type: 'text',
            label: 'Object',
            toggle_hint: 'Use Entityset name',
            hint: 'Provide any SuccessFactors object(Entityset name), e.g. User.'
          }
        },
        {
          name: 'key_column', control_type: 'multiselect',
          delimiter: ',',
          pick_list: 'unique_keys',
          pick_list_params: { object_name: 'object_name' },
          label: 'Object unique key',
          hint: 'Select key column',
          optional: false,
          toggle_hint: 'Select key',
          toggle_field: {
            name: 'key_column',
            type: 'string',
            control_type: 'text',
            label: 'Object unique key column',
            toggle_hint: 'Use object unique column name',
            hint: 'Object key column - internal name'
          }
        }
      ],

      input_fields: lambda do |object_definitions|
        [
          {
            name: 'objects',
            type: 'array',
            of: 'object',
            properties: object_definitions['object_upsert']
          }
        ]
      end,

      execute: lambda do |_connection, input|
        object_name = input.delete('object_name')
        key_column = input.delete('key_column')
        date_fields = call(:date_fields, object_name: object_name)
        payload = input['objects'].map do |obj|
          key_string = key_column.split(',').map do |k|
            date_fields.include?(k) ? "#{k}=datetime'#{obj[k].utc.iso8601}'" : "#{k}='#{obj[k]}'"
          end.join(',')

          {
            '__metadata': {
              'uri': object_name + "(#{key_string})"
            }
          }.merge(call('input_parser', input: obj, date_fields: date_fields))
        end
        objects = post('/odata/v2/upsert', payload).params("$format": 'json').
                  after_error_response(/.*/) do |_code, body, _header, message|
                    error("#{message}: #{body}")
                  end['d']
        { objects: objects }
      end,

      output_fields: lambda do |_object_definitions|
        [
          { name: 'objects', type: 'array', of: 'object',
            properties: [
              { name: 'key', label: 'ID' },
              { name: 'status' },
              { name: 'editStatus' },
              { name: 'message', label: 'Error message' },
              { name: 'index', type: 'integer' },
              { name: 'httpCode', type: 'integer' },
              { name: 'inlineResults' }
            ] }
        ]
      end,

      sample_output: lambda do
        {
          key: '31917',
          status: 'OK',
          editStatus: 'UPDATED',
          message: 'Error message',
          index: '1',
          httpCode: '204',
          inlineResults: ''
        }
      end
    },

    get_object: {
      title: 'Get record details',
      subtitle: 'Retrieve the details of any record e.g. user via its key columns',
      description: lambda do |_connection, pick_list|
        "Get <span class='provider'> " \
        "#{pick_list['object_name'] || 'record'}</span> details" \
          " in <span class='provider'>SuccessFactors</span>"
      end,

      help: 'Retrieve the details of any record, e.g. user, via its key column\'s.' \
      ' Provide value for all key columns, otherwise it returns error when there is no match.',

      config_fields: [
        {
          name: 'object_name', control_type: 'select',
          pick_list: 'entity_set',
          label: 'Object',
          hint: 'Select any SuccessFactors object, e.g. user',
          optional: false,
          toggle_hint: 'Select Object',
          toggle_field: {
            name: 'object_name',
            type: 'string',
            control_type: 'text',
            label: 'Object',
            toggle_hint: 'Use Entityset name',
            hint: 'Provide any SuccessFactors object(Entityset name), e.g. User.'
          }
        },
        {
          name: 'associations', control_type: 'text-area',
          label: 'Associations',
          optional: true,
          sticky: true,
          hint: <<-HINT
                Type in the details of your association below (one per line).
                This will generate additional input fields below. for example:
                <b>cust_cost_center-FOCostCenter-OneToMany</b> where <b>cust_cost_center</b>
                would be your <b>Property Name</b>, <b>FOCostCenter</b> would be your
                <b>Type</b>, <b>OneToMany</b> would be your <b>Relationship type</b>.
          HINT
        }
      ],

      input_fields: lambda do |object_definitions|
        object_definitions['object_get']
      end,

      execute: lambda do |_connection, input, _, e_o_s|
        date_fields = call(:date_fields, object_name: input['object_name'])
        associations = input.delete('associations')&.split("\n")
        params = { '$format': 'json' }
        if associations.present?
          params['$expand'] = associations.map do |obj|
            obj.split('-').first
          end&.join(',')
        end
        key_string = input.except('object_name').map do |k, v|
          date_fields.include?(k) ? "#{k}=datetime'#{v.utc.iso8601}'" : "#{k}='#{v}'"
        end.join(',')
        output = get("/odata/v2/#{input['object_name']}(#{key_string})").
                 params(params).
                 after_error_response(/.*/) do |_code, body, _header, message|
                   error("#{message}: #{body}")
                 end['d']
        associations&.each do |obj|
          key = obj.split('-').first
          asso_e_o_s = e_o_s.select { |field| field['name'] == key }.first&.[]('properties')
          if output&.dig(key, 'results').present?
            output[key]['results'] = output.dig(key, 'results').
                                     map do |asso_obj|
                                       call('output_parser',
                                            output: asso_obj,
                                            e_o_s: asso_e_o_s&.first&.[]('properties'))
                                     end
          end
          output[key] = call('output_parser', output: output[key], e_o_s: asso_e_o_s)
        end
        call('output_parser', output: output, e_o_s: e_o_s)
      end,

      output_fields: lambda do |object_definitions|
        object_definitions['object_output']
      end,

      sample_output: lambda do |_connection, input|
        date_fields = call('date_fields', object_name: input['object_name'])
        object = get("/odata/v2/#{input['object_name']}").params('$top': 1).dig('d', 'results', 0)
        call('output_parse_trigger', obj: object, date_fields: date_fields) || {}
      end
    }
  },

  triggers: {
    new_updated_object: {
      title: 'New/Updated object',
      subtitle: 'Triggers when selected SuccessFactors object e.g. user created/updated',
      description: lambda do |_connection, pick_list|
        "New/Updated <span class='provider'> " \
        "#{pick_list['object_name'] || 'record'}</span>" \
          " in <span class='provider'>SuccessFactors</span>"
      end,
      help: 'Triggers when selected SuccessFactors object, e.g. user, is created or updated.<br/>' \
      'Note: Do not change the triggger object after the recipe started/tested.',
      config_fields: [
        { name: 'object_name', control_type: 'select',
          pick_list: 'entity_set',
          label: 'Object',
          hint: 'Select any SuccessFactors object, e.g. user',
          optional: false,
          toggle_hint: 'Select Object',
          toggle_field:
            { name: 'object_name',
              type: 'string',
              control_type: 'text',
              label: 'Object',
              toggle_hint: 'Use Entityset name',
              hint: 'Provide any SuccessFactors object(Entityset name), e.g. User.' } }
      ],

      input_fields: lambda do |_connection|
        [
          { name: 'key_column', control_type: 'select',
            pick_list: 'unique_keys',
            pick_list_params: { object_name: 'object_name' },
            label: 'Object unique key',
            hint: 'Select key column',
            optional: false,
            toggle_hint: 'Select key',
            toggle_field: {
              name: 'key_column',
              type: 'string',
              control_type: 'text',
              label: 'Object unique key column',
              toggle_hint: 'Use object unique column name',
              hint: 'Object key column - internal name'
            } },
          { name: 'since',
            label: 'When first started, this recipe should pick up events from',
            hint: 'When you start recipe for the first time, ' \
            'it picks up trigger events from this specified date and time. ' \
            'Leave empty to get records created or updated one hour ago',
            sticky: true,
            type: 'timestamp' }
        ]
      end,

      poll: lambda do |_connection, input, closure|
        page_size = 100
        object_name = closure&.[]('object_name') || input.delete('object_name')
        key_column = closure&.[]('key_column') || input.delete('key_column')
        date_fields = closure&.[]('date_fields') ||
                      call('date_fields', object_name: object_name)
        skip = closure&.[]('skip') || 0
        last_updated_since = closure&.[]('last_modified_datetime') ||
                             (input['since'].presence || 1.hour.ago).to_time.utc.iso8601
        response = get("/odata/v2/#{object_name}").
                   params(call('generate_params', since: last_updated_since,
                                                  skip: skip, limit: page_size))['d']
        final_objects = response['results']&.map do |obj|
          obj['object_id'] = obj[key_column] + '-' +
                             obj['lastModifiedDateTime'].scan(/[-]*\d+/)[0].to_s
          call('output_parse_trigger', obj: obj, date_fields: date_fields)
        end
        has_more_pages = skip + page_size < response&.[]('__count').to_i
        value = call('get_closure_value', flag: has_more_pages,
                                          skip: skip, obj: final_objects, page: page_size)
        closure = call('generate_closure',
                       object_name: object_name,
                       last_updated_since: value['last_updated_since'],
                       key_column: key_column,
                       date_fields: date_fields,
                       skip: value['skip'])
        { events: final_objects, next_poll: closure, can_poll_more: has_more_pages }
      end,

      dedup: lambda do |object|
        object['object_id']
      end,

      output_fields: lambda do |object_defintions|
        object_defintions['object_output']
      end,

      sample_output: lambda do |_connection, input|
        date_fields = call('date_fields', object_name: input['object_name'])
        object = get("/odata/v2/#{input['object_name']}").
                 params('$top': 1).dig('d', 'results')
        call('output_parse_trigger', obj: object, date_fields: date_fields) || {}
      end
    },

    new_updated_object_batch: {
      title: 'New/Updated objects in batch',
      subtitle: 'Retrieve a list of records created or updated since last' \
      ' time the recipe is triggered',
      description: lambda do |_connection, pick_list|
        "New/Updated <span class='provider'> " \
        "#{pick_list['object_name'] || 'records'}</span> in batch" \
          " in <span class='provider'>SuccessFactors</span>"
      end,
      help: 'Triggers when selected SuccessFactors object, e.g. user, is created or updated.<br/>' \
      'Note: Do not change the triggger object after the recipe started/tested.',
      config_fields: [
        { name: 'object_name', control_type: 'select',
          pick_list: 'entity_set',
          label: 'Object',
          hint: 'Select any SuccessFactors object, e.g. user',
          optional: false,
          toggle_hint: 'Select Object',
          toggle_field:
            { name: 'object_name',
              type: 'string',
              control_type: 'text',
              label: 'Object',
              toggle_hint: 'Use Entityset name',
              hint: 'Provide any SuccessFactors object(Entityset name), e.g. User.' } }
      ],

      input_fields: lambda do |_connection|
        [
          { name: 'key_column', control_type: 'select',
            pick_list: 'unique_keys',
            pick_list_params: { object_name: 'object_name' },
            label: 'Object unique key',
            hint: 'Select key column',
            optional: false,
            toggle_hint: 'Select key',
            toggle_field: {
              name: 'key_column',
              type: 'string',
              control_type: 'text',
              label: 'Object unique key column',
              toggle_hint: 'Use object unique column name',
              hint: 'Object key column - internal name'
            } },
          { name: 'since',
            label: 'When first started, this recipe should pick up events from',
            hint: 'When you start recipe for the first time, ' \
            'it picks up trigger events from this specified date and time. ' \
            'Leave empty to get records created or updated one hour ago',
            sticky: true,
            type: 'timestamp' }
        ]
      end,

      poll: lambda do |_connection, input, closure|
        page_size = 500
        object_name = closure&.[]('object_name') || input.delete('object_name')
        key_column = closure&.[]('key_column') || input.delete('key_column')
        date_fields = closure&.[]('date_fields') ||
                      call('date_fields', object_name: object_name)
        skip = closure&.[]('skip') || 0
        last_updated_since = closure&.[]('last_modified_datetime') ||
                             (input['since'].presence || 1.hour.ago).to_time.utc.iso8601
        response = get("/odata/v2/#{object_name}").
                   params(call('generate_params', since: last_updated_since,
                                                  skip: skip, limit: page_size))['d']
        final_objects = response['results']&.map do |obj|
          obj['object_id'] = obj[key_column] + '-' +
                             obj['lastModifiedDateTime'].scan(/[-]*\d+/)[0].to_s
          call('output_parse_trigger', obj: obj, date_fields: date_fields)
        end
        closure = if (has_more_pages  = skip + page_size < response&.[]('__count').to_i)
          {
            object_name: object_name,
            last_modified_datetime: last_updated_since,
            key_column: key_column,
            date_fields: date_fields,
            skip: skip + page_size
          }
        else
          last_updated_since = if final_objects.present?
            final_objects.last['lastModifiedDateTime']&.to_time&.utc&.iso8601
          else
            now.to_time.utc.iso8601
          end
          {
            object_name: object_name,
            last_modified_datetime: last_updated_since,
            key_column: key_column,
            date_fields: date_fields,
            skip: 0
          }
        end
         batches = []
         if final_objects&.length > 0
           batches << { 'batch_id': Time.now.to_i, records: final_objects }
         end
        { events: batches , next_poll: closure, can_poll_more: has_more_pages }
      end,

      dedup: lambda do |object|
        object['batch_id']
      end,

      output_fields: lambda do |object_defintions|
        [
          { name: 'batch_id' },
          { name: 'records', type: 'array', of: 'object',
            properties: object_defintions['object_output'] }
        ]
      end,
      sample_output: lambda do |_connection, input|
        date_fields = call('date_fields', object_name: input['object_name'])
        object = get("/odata/v2/#{input['object_name']}").
                 params('$top': 1).dig('d', 'results')
        { 'batch_id': 159_068_227_8,
          'records': call('output_parse_trigger', obj: object, date_fields: date_fields) || {} }
      end
    }
  },

  pick_lists: {
    entity_set: lambda do |_connection|
      call('get_entity_set')&.
      map do |obj|
        label = if (obj['@label'] || obj['@Name']).labelize == obj['@Name'].labelize
                  (obj['@label'] || obj['@Name']).labelize
                else
                  "#{(obj['@label'] || obj['@Name']).labelize} (#{obj['@Name']})"
                end
        [label, obj['@Name']]
      end
    end,

    unique_keys: lambda do |_connection, object_name:|
      call('get_metadata', object_name: object_name)&.
      dig('edmx:Edmx', 0, 'edmx:DataServices', 0, 'Schema', 1,
          'EntityType', 0, 'Key', 0, 'PropertyRef')&.
      # Reject Date time fields in object key columns
      reject { |property| property['@Name'].include?('date') || property['@Name'].include?('Date') }&.
      map { |property| [property['@Name'].labelize, property['@Name']] } || []
    end,

    entity_set_create: lambda do |_connection|
      call('get_entity_set')&.
      select { |field| field['@creatable'] == 'true' }&.
      map do |obj|
        label = if (obj['@label'] || obj['@Name']).labelize == obj['@Name'].labelize
                  (obj['@label'] || obj['@Name']).labelize
                else
                  "#{(obj['@label'] || obj['@Name']).labelize} (#{obj['@Name']})"
                end
        [label, obj['@Name']]
      end
    end,

    entity_set_update: lambda do |_connection|
      call('get_entity_set')&.
      select { |field| field['@updatable'] == 'true' }&.
      map do |obj|
        label = if (obj['@label'] || obj['@Name']).labelize == obj['@Name'].labelize
                  (obj['@label'] || obj['@Name']).labelize
                else
                  "#{(obj['@label'] || obj['@Name']).labelize} (#{obj['@Name']})"
                end
        [label, obj['@Name']]
      end
    end,

    entity_set_upsert: lambda do
      call('get_entity_set')&.
      select { |field| field['@upsertable'] == 'true' }&.
      map do |obj|
        label = if (obj['@label'] || obj['@Name']).labelize == obj['@Name'].labelize
                  (obj['@label'] || obj['@Name']).labelize
                else
                  "#{(obj['@label'] || obj['@Name']).labelize} (#{obj['@Name']})"
                end
        [label, obj['@Name']]
      end
    end
  }
}
